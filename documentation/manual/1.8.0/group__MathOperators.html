
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="bitpit is a C++ library for scientific High Performance Computing." />
    <meta name="keywords" content="bitpit, HPC, octree, PABLO, levelset, RBF, mesh, grid" />
    <link rel="shortcut icon" href="/bitpit/images/bitpit.ico" type="image/x-icon">
    <link rel="icon" href="/bitpit/images/bitpit.ico" type="image/x-icon">
    <link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Lato:400,700'>
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/base.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/cookies.css" />
    <script type="text/javascript" src="/bitpit/scripts/jquery-1.12.4.min.js"></script>
    <script type="text/javascript" src="/bitpit/scripts/cookies.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-93686152-1', 'auto');
        ga('send', 'pageview');
    </script>
    <script type="text/javascript">
        $(document).ready(function(){
        });
    </script>
    <meta name="generator" content="Doxygen 1.9.3"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="manual.css" rel="stylesheet" type="text/css"/>
    <title>bitpit - Manual - Mathematical Operators</title>
</head>
<body>
<div id="cookie-warning">
        <p id="accept-cookies" class="button">Continue</p>
        <h3>Our website uses cookies</h3>
        <p>
        This website uses cookies. By continuing to use this website you are
        giving consent to cookies being used. For information on cookies
        and how you can disable them visit our
        <a href="/bitpit/privacy.html">Privacy Policy</a>.
        </p>
</div>
<!-- Header-->
<div id="header" class="">
    <div class="logo"><a href="/bitpit">&nbsp;</a></div>
    <div class="menu-line"></div>
<ul class="menu">
    <li>
        <a href="/bitpit/modules/index.html">Overview</a>
    </li>
    <li class="current">
        <span>Documentation</span>
        <ul class="sub-menu">
            <li><a href="/bitpit/documentation/installation.html">Installation guide</a></li>
            <li><a href="/bitpit/documentation/manual/1.8.0/index.html">Programmer's manual</a></li>
        </ul>
    </li>
    <li>
        <a href="/bitpit/downloads">Downloads</a>
    </li>
</ul>
<script type="text/javascript">
$('.menu li').hover(
    function() {
        $('ul', this).css('height', 'auto');
        $('ul', this).stop().slideDown(200);
    },
    function() {
        $('ul', this).stop().slideUp(200, function() {
            $(this).attr('style','');
        });
    }
);
</script>
</div>
<div id="content" class="">
<div id="manual">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Mathematical Operators<div class="ingroups"><a class="el" href="group__OperatorsFunctions.html">Operators and Functions</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mathematical Operators:</div>
<div class="dyncontent">
<div class="center"><img src="group__MathOperators.png" border="0" usemap="#agroup____MathOperators" alt=""/></div>
<map name="agroup____MathOperators" id="agroup____MathOperators">
<area shape="rect" title=" " alt="" coords="219,5,380,31"/>
<area shape="rect" href="group__OperatorsFunctions.html" title=" " alt="" coords="5,5,171,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="memitem:gad5dea4f58756ac4d324d7a96fb16d095"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gad5dea4f58756ac4d324d7a96fb16d095"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gad5dea4f58756ac4d324d7a96fb16d095">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gad5dea4f58756ac4d324d7a96fb16d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8b9ef31e10db314beda4425430ec00"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga8d8b9ef31e10db314beda4425430ec00"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8d8b9ef31e10db314beda4425430ec00">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8d8b9ef31e10db314beda4425430ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e7b30a7bf5b0fc641f7f26ddbe2348"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gac6e7b30a7bf5b0fc641f7f26ddbe2348"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac6e7b30a7bf5b0fc641f7f26ddbe2348">operator+</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gac6e7b30a7bf5b0fc641f7f26ddbe2348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6184fa5a54822e79d24116653a7cc02a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga6184fa5a54822e79d24116653a7cc02a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6184fa5a54822e79d24116653a7cc02a">operator+</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga6184fa5a54822e79d24116653a7cc02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6eb7203ac9d396281ce7948ca77b99b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gac6eb7203ac9d396281ce7948ca77b99b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac6eb7203ac9d396281ce7948ca77b99b">operator+</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac6eb7203ac9d396281ce7948ca77b99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbf957c8e29539b76d5a29aab13ebca"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3fbf957c8e29539b76d5a29aab13ebca"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3fbf957c8e29539b76d5a29aab13ebca">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3fbf957c8e29539b76d5a29aab13ebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a70766353e95c78ae9b5c7b56b5ba7"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga89a70766353e95c78ae9b5c7b56b5ba7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga89a70766353e95c78ae9b5c7b56b5ba7">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga89a70766353e95c78ae9b5c7b56b5ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4dea55e35977b6cc046df52e78db126"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaf4dea55e35977b6cc046df52e78db126"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaf4dea55e35977b6cc046df52e78db126">operator+=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf4dea55e35977b6cc046df52e78db126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41fc7099c1967c331395b8f2bbfba52"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gad41fc7099c1967c331395b8f2bbfba52"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gad41fc7099c1967c331395b8f2bbfba52">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gad41fc7099c1967c331395b8f2bbfba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c05b1ac15cbd3631059190bfa71363"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaf3c05b1ac15cbd3631059190bfa71363"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaf3c05b1ac15cbd3631059190bfa71363">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf3c05b1ac15cbd3631059190bfa71363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e31b587498592d868281e23e41968ec"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga0e31b587498592d868281e23e41968ec"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga0e31b587498592d868281e23e41968ec">operator-</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga0e31b587498592d868281e23e41968ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5133809dcbdc513c238bedb9943b0375"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga5133809dcbdc513c238bedb9943b0375"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5133809dcbdc513c238bedb9943b0375">operator-</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga5133809dcbdc513c238bedb9943b0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc769ecc8b03395adc1d5ac5aab1e89c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gacc769ecc8b03395adc1d5ac5aab1e89c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gacc769ecc8b03395adc1d5ac5aab1e89c">operator-</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gacc769ecc8b03395adc1d5ac5aab1e89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08fe06026beca2ceb67f0dceed31b531"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga08fe06026beca2ceb67f0dceed31b531"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga08fe06026beca2ceb67f0dceed31b531">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga08fe06026beca2ceb67f0dceed31b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fefa8b35f1f38d70c2dfff298346e5"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga67fefa8b35f1f38d70c2dfff298346e5"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga67fefa8b35f1f38d70c2dfff298346e5">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga67fefa8b35f1f38d70c2dfff298346e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3c8bf3bd9204c55d991affed1bdfb0"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8b3c8bf3bd9204c55d991affed1bdfb0"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8b3c8bf3bd9204c55d991affed1bdfb0">operator-=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b3c8bf3bd9204c55d991affed1bdfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877548575dd334f23f36fb0f58049a35"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga877548575dd334f23f36fb0f58049a35"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga877548575dd334f23f36fb0f58049a35">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga877548575dd334f23f36fb0f58049a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4415b55222fb22edfccc7211c3d28e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gacd4415b55222fb22edfccc7211c3d28e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gacd4415b55222fb22edfccc7211c3d28e">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gacd4415b55222fb22edfccc7211c3d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002eceb71d95d7a8ea55c4086f4bc19f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga002eceb71d95d7a8ea55c4086f4bc19f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga002eceb71d95d7a8ea55c4086f4bc19f">operator*</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga002eceb71d95d7a8ea55c4086f4bc19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8b5e13a060be1c2d00ea525f55cd15"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8d8b5e13a060be1c2d00ea525f55cd15"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8d8b5e13a060be1c2d00ea525f55cd15">operator*</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga8d8b5e13a060be1c2d00ea525f55cd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab938def11e8fa33e200234a7f87fd60b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gab938def11e8fa33e200234a7f87fd60b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gab938def11e8fa33e200234a7f87fd60b">operator*</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab938def11e8fa33e200234a7f87fd60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01dd64145ceceed6f11d076b595dd5b1"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga01dd64145ceceed6f11d076b595dd5b1"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga01dd64145ceceed6f11d076b595dd5b1">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga01dd64145ceceed6f11d076b595dd5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc5c8373acd57721d425876bffeebd9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3cc5c8373acd57721d425876bffeebd9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3cc5c8373acd57721d425876bffeebd9">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga3cc5c8373acd57721d425876bffeebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276768d794bae4dfcf7b07d269b4a6b3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga276768d794bae4dfcf7b07d269b4a6b3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga276768d794bae4dfcf7b07d269b4a6b3">operator*=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga276768d794bae4dfcf7b07d269b4a6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1224ce75f96a1531fa86fa4365f725"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1f1224ce75f96a1531fa86fa4365f725"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga1f1224ce75f96a1531fa86fa4365f725">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1f1224ce75f96a1531fa86fa4365f725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571bed97e1f9dc43162ed05c86c7297f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga571bed97e1f9dc43162ed05c86c7297f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga571bed97e1f9dc43162ed05c86c7297f">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga571bed97e1f9dc43162ed05c86c7297f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37768937a2c3d0c96284bd20f2799fc7"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga37768937a2c3d0c96284bd20f2799fc7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga37768937a2c3d0c96284bd20f2799fc7">operator/</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga37768937a2c3d0c96284bd20f2799fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b">operator/</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46faa02af5bf7ce75bbb1ba8b16cf16"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gac46faa02af5bf7ce75bbb1ba8b16cf16"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac46faa02af5bf7ce75bbb1ba8b16cf16">operator/</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac46faa02af5bf7ce75bbb1ba8b16cf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8622b683eb6d38f3ca2eee11f9045d"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga7b8622b683eb6d38f3ca2eee11f9045d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga7b8622b683eb6d38f3ca2eee11f9045d">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga7b8622b683eb6d38f3ca2eee11f9045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab7a46cda45f5c95e31e14b0cb2d44a"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gadab7a46cda45f5c95e31e14b0cb2d44a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gadab7a46cda45f5c95e31e14b0cb2d44a">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gadab7a46cda45f5c95e31e14b0cb2d44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edd77a9cc40f7e0640eeef310d60c32"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga1edd77a9cc40f7e0640eeef310d60c32"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga1edd77a9cc40f7e0640eeef310d60c32">operator/=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga1edd77a9cc40f7e0640eeef310d60c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga71b722bb9670854ddfcb0e867620083f">operator+</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga71b722bb9670854ddfcb0e867620083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga97948a906b46303c7c654c84149dd9ee">operator+</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga97948a906b46303c7c654c84149dd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gade9e3b35c5ed9d228bd242eaee48df2f">operator+</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga06cb1fde86b09befdc0b42d99fdbf31f">operator+</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6e163effd6e58c7f726fbd29f5c1e42c">operator+</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e384cc363f7a533e84233d0781d063"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab1e384cc363f7a533e84233d0781d063"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gab1e384cc363f7a533e84233d0781d063">operator+=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gab1e384cc363f7a533e84233d0781d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2547f5a2792bfa7f168003900c31a320"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2547f5a2792bfa7f168003900c31a320"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga2547f5a2792bfa7f168003900c31a320">operator+=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga2547f5a2792bfa7f168003900c31a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706563d638b3361e51e8a376d86e4206"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga706563d638b3361e51e8a376d86e4206"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga706563d638b3361e51e8a376d86e4206">operator+=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga706563d638b3361e51e8a376d86e4206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga39b3f7b4938cab605085cc4a2621c0c1">operator-</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8b14f28bd4c6544e7af363162827a3f9">operator-</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga81916c6a47f24b1ec5bfb890a7e71d93">operator-</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gacd869d6ee14d5683b3fa4fcefc5ae5fa">operator-</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga043799b065672b453653cccc836df3e0">operator-</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043799b065672b453653cccc836df3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8ca10f1be3a4ef73728199de095951"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6c8ca10f1be3a4ef73728199de095951"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6c8ca10f1be3a4ef73728199de095951">operator-=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga6c8ca10f1be3a4ef73728199de095951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae2c7c7dd3909e0c79b00ad4f179d07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0ae2c7c7dd3909e0c79b00ad4f179d07"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga0ae2c7c7dd3909e0c79b00ad4f179d07">operator-=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga0ae2c7c7dd3909e0c79b00ad4f179d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59762030d80b896a612f791781fcd777"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga59762030d80b896a612f791781fcd777"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga59762030d80b896a612f791781fcd777">operator-=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga59762030d80b896a612f791781fcd777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga2bd9e5a66f35bd5cfe4903f2405c87ba">operator*</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac44d2a365e67d48fc144cf576f4e003e">operator*</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac44d2a365e67d48fc144cf576f4e003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga92fa8968855d071e34808339503fe37b">operator*</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga92fa8968855d071e34808339503fe37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae5c14d292d187b6a76d4acd8068e2ec3">operator*</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5be9b506ad98c26a66c46e3a63569af2">operator*</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc463927e1f8a7a6104ca8338bd81804"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadc463927e1f8a7a6104ca8338bd81804"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gadc463927e1f8a7a6104ca8338bd81804">operator*=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gadc463927e1f8a7a6104ca8338bd81804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4a87f31a74b77936427c1f3ea9a87b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadd4a87f31a74b77936427c1f3ea9a87b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gadd4a87f31a74b77936427c1f3ea9a87b">operator*=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gadd4a87f31a74b77936427c1f3ea9a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa472781ea862caff490ba96e6cb222a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa472781ea862caff490ba96e6cb222a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaa472781ea862caff490ba96e6cb222a4">operator*=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaa472781ea862caff490ba96e6cb222a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4d9d274530965b0fb1a331706535b2b0">operator/</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4d9d274530965b0fb1a331706535b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga9ee9c85d60d975df735a1c35fcf02e20">operator/</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac6fff4de3b1f6cbedc8b80e0f29b673f">operator/</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaaa8866a1e9873585704acfa8169ba1f4">operator/</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gab73845b94584f17c7e810e27cba36f5d">operator/</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab73845b94584f17c7e810e27cba36f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c760e4fb64cdc1b52bf2c589d77436e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9c760e4fb64cdc1b52bf2c589d77436e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga9c760e4fb64cdc1b52bf2c589d77436e">operator/=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga9c760e4fb64cdc1b52bf2c589d77436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac299c00791946cdbae7cdb8a54b3fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ac299c00791946cdbae7cdb8a54b3fc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga9ac299c00791946cdbae7cdb8a54b3fc">operator/=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ac299c00791946cdbae7cdb8a54b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7471ac1e321cb428d90510d46edbc7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7d7471ac1e321cb428d90510d46edbc7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga7d7471ac1e321cb428d90510d46edbc7">operator/=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7d7471ac1e321cb428d90510d46edbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab938def11e8fa33e200234a7f87fd60b" name="gab938def11e8fa33e200234a7f87fd60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab938def11e8fa33e200234a7f87fd60b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::array.</p>
<p >Perform the element-wise product between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if x[i][j] and y are std::array, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00871">871</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga877548575dd334f23f36fb0f58049a35" name="ga877548575dd334f23f36fb0f58049a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877548575dd334f23f36fb0f58049a35">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::array.</p>
<p >Perform the element-wise product between two arrays (x and y) and returns a array z s.t. z[i] = x[i] * y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00715">715</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gacd4415b55222fb22edfccc7211c3d28e" name="gacd4415b55222fb22edfccc7211c3d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4415b55222fb22edfccc7211c3d28e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::array.</p>
<p >Perform the element-wise product between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] * y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00754">754</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5be9b506ad98c26a66c46e3a63569af2" name="ga5be9b506ad98c26a66c46e3a63569af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be9b506ad98c26a66c46e3a63569af2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::vector.</p>
<p >Perform the element-wise product between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if x[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00862">862</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga2bd9e5a66f35bd5cfe4903f2405c87ba" name="ga2bd9e5a66f35bd5cfe4903f2405c87ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd9e5a66f35bd5cfe4903f2405c87ba">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::vector.</p>
<p >Perform the element-wise product between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] * y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00703">703</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac44d2a365e67d48fc144cf576f4e003e" name="gac44d2a365e67d48fc144cf576f4e003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44d2a365e67d48fc144cf576f4e003e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::vector.</p>
<p >Perform the element-wise product between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] * y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00743">743</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8d8b5e13a060be1c2d00ea525f55cd15" name="ga8d8b5e13a060be1c2d00ea525f55cd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8b5e13a060be1c2d00ea525f55cd15">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::array.</p>
<p >Perform the element-wise product between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if y[i][j] and y are std::array, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00831">831</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga002eceb71d95d7a8ea55c4086f4bc19f" name="ga002eceb71d95d7a8ea55c4086f4bc19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002eceb71d95d7a8ea55c4086f4bc19f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::array.</p>
<p >Perform the element-wise product between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x * y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00793">793</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gae5c14d292d187b6a76d4acd8068e2ec3" name="gae5c14d292d187b6a76d4acd8068e2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c14d292d187b6a76d4acd8068e2ec3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::vector.</p>
<p >Perform the element-wise product between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if y[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00821">821</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga92fa8968855d071e34808339503fe37b" name="ga92fa8968855d071e34808339503fe37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92fa8968855d071e34808339503fe37b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator* for std::vector.</p>
<p >Perform the element-wise product between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x * y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p >The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00783">783</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga276768d794bae4dfcf7b07d269b4a6b3" name="ga276768d794bae4dfcf7b07d269b4a6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276768d794bae4dfcf7b07d269b4a6b3">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator*= for std::array.</p>
<p >Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00987">987</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga01dd64145ceceed6f11d076b595dd5b1" name="ga01dd64145ceceed6f11d076b595dd5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01dd64145ceceed6f11d076b595dd5b1">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator*= for std::array.</p>
<p >Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00911">911</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga3cc5c8373acd57721d425876bffeebd9" name="ga3cc5c8373acd57721d425876bffeebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cc5c8373acd57721d425876bffeebd9">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator*= for std::array.</p>
<p >Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00949">949</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaa472781ea862caff490ba96e6cb222a4" name="gaa472781ea862caff490ba96e6cb222a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa472781ea862caff490ba96e6cb222a4">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator*= for std::vector.</p>
<p >Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00979">979</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gadc463927e1f8a7a6104ca8338bd81804" name="gadc463927e1f8a7a6104ca8338bd81804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc463927e1f8a7a6104ca8338bd81804">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator*= for std::vector.</p>
<p >Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00901">901</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gadd4a87f31a74b77936427c1f3ea9a87b" name="gadd4a87f31a74b77936427c1f3ea9a87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd4a87f31a74b77936427c1f3ea9a87b">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator*= for std::vector.</p>
<p >Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00940">940</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac6eb7203ac9d396281ce7948ca77b99b" name="gac6eb7203ac9d396281ce7948ca77b99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6eb7203ac9d396281ce7948ca77b99b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::array.</p>
<p >Perform the element-wise sum between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00230">230</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gad5dea4f58756ac4d324d7a96fb16d095" name="gad5dea4f58756ac4d324d7a96fb16d095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5dea4f58756ac4d324d7a96fb16d095">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::array</p>
<p >Perform the element-wise sum between two arrays (x and y) and returns a array z s.t. z[i] = x[i] + y[i] for all i = 0, ..., d where d = x.size() = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00074">74</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga8d8b9ef31e10db314beda4425430ec00" name="ga8d8b9ef31e10db314beda4425430ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8b9ef31e10db314beda4425430ec00">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::array.</p>
<p >Perform the element-wise sum between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] + y for all i = 0, ..., d where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00113">113</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga06cb1fde86b09befdc0b42d99fdbf31f" name="ga06cb1fde86b09befdc0b42d99fdbf31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cb1fde86b09befdc0b42d99fdbf31f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::vector.</p>
<p >Perform the element-wise sum between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00187">187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga71b722bb9670854ddfcb0e867620083f" name="ga71b722bb9670854ddfcb0e867620083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b722bb9670854ddfcb0e867620083f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::vector.</p>
<p >Perform the element-wise sum between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] + y[i] for all i = 0, ..., n-1 where n = std::min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00069">69</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga97948a906b46303c7c654c84149dd9ee" name="ga97948a906b46303c7c654c84149dd9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97948a906b46303c7c654c84149dd9ee">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::vector.</p>
<p >Perform the element-wise sum between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] + y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00109">109</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6184fa5a54822e79d24116653a7cc02a" name="ga6184fa5a54822e79d24116653a7cc02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6184fa5a54822e79d24116653a7cc02a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::array.</p>
<p >Perform the element-wise sum between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00190">190</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gac6e7b30a7bf5b0fc641f7f26ddbe2348" name="gac6e7b30a7bf5b0fc641f7f26ddbe2348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e7b30a7bf5b0fc641f7f26ddbe2348">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::array.</p>
<p >Perform the element-wise sum between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x + y[i] for all i = 0, ..., d where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00152">152</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga6e163effd6e58c7f726fbd29f5c1e42c" name="ga6e163effd6e58c7f726fbd29f5c1e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e163effd6e58c7f726fbd29f5c1e42c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::vector.</p>
<p >Perform the element-wise sum between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00228">228</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gade9e3b35c5ed9d228bd242eaee48df2f" name="gade9e3b35c5ed9d228bd242eaee48df2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9e3b35c5ed9d228bd242eaee48df2f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+ for std::vector.</p>
<p >Perform the element-wise sum between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x + y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p >The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00149">149</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaf4dea55e35977b6cc046df52e78db126" name="gaf4dea55e35977b6cc046df52e78db126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4dea55e35977b6cc046df52e78db126">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+= for std::array.</p>
<p >Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00344">344</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga3fbf957c8e29539b76d5a29aab13ebca" name="ga3fbf957c8e29539b76d5a29aab13ebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fbf957c8e29539b76d5a29aab13ebca">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+= for std::array.</p>
<p >Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00268">268</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga89a70766353e95c78ae9b5c7b56b5ba7" name="ga89a70766353e95c78ae9b5c7b56b5ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a70766353e95c78ae9b5c7b56b5ba7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+= for std::array.</p>
<p >Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga706563d638b3361e51e8a376d86e4206" name="ga706563d638b3361e51e8a376d86e4206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706563d638b3361e51e8a376d86e4206">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+= for std::vector.</p>
<p >Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00345">345</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gab1e384cc363f7a533e84233d0781d063" name="gab1e384cc363f7a533e84233d0781d063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e384cc363f7a533e84233d0781d063">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+= for std::vector.</p>
<p >Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00267">267</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga2547f5a2792bfa7f168003900c31a320" name="ga2547f5a2792bfa7f168003900c31a320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2547f5a2792bfa7f168003900c31a320">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator+= for std::vector.</p>
<p >Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gacc769ecc8b03395adc1d5ac5aab1e89c" name="gacc769ecc8b03395adc1d5ac5aab1e89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc769ecc8b03395adc1d5ac5aab1e89c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::array.</p>
<p >Perform the element-wise difference between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., e-1, i = 0, ..., d-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::array, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00541">541</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gad41fc7099c1967c331395b8f2bbfba52" name="gad41fc7099c1967c331395b8f2bbfba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41fc7099c1967c331395b8f2bbfba52">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::array.</p>
<p >Perform the element-wise difference between two arrays (x and y) and returns a array z s.t. z[i] = x[i] - y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00385">385</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaf3c05b1ac15cbd3631059190bfa71363" name="gaf3c05b1ac15cbd3631059190bfa71363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c05b1ac15cbd3631059190bfa71363">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::array.</p>
<p >Perform the element-wise difference between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] - y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00424">424</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga043799b065672b453653cccc836df3e0" name="ga043799b065672b453653cccc836df3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043799b065672b453653cccc836df3e0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::vector.</p>
<p >Perform the element-wise difference between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::vector, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00545">545</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga39b3f7b4938cab605085cc4a2621c0c1" name="ga39b3f7b4938cab605085cc4a2621c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39b3f7b4938cab605085cc4a2621c0c1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::vector.</p>
<p >Perform the element-wise difference between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] - y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00386">386</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8b14f28bd4c6544e7af363162827a3f9" name="ga8b14f28bd4c6544e7af363162827a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b14f28bd4c6544e7af363162827a3f9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::vector.</p>
<p >Perform the element-wise difference between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] - y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00426">426</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga5133809dcbdc513c238bedb9943b0375" name="ga5133809dcbdc513c238bedb9943b0375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5133809dcbdc513c238bedb9943b0375">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::array.</p>
<p >Perform the element-wise difference between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::array, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00501">501</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga0e31b587498592d868281e23e41968ec" name="ga0e31b587498592d868281e23e41968ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e31b587498592d868281e23e41968ec">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::array.</p>
<p >Perform the element-wise difference between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x - y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00463">463</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gacd869d6ee14d5683b3fa4fcefc5ae5fa" name="gacd869d6ee14d5683b3fa4fcefc5ae5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd869d6ee14d5683b3fa4fcefc5ae5fa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::vector.</p>
<p >Perform the element-wise difference between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::vector, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00504">504</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga81916c6a47f24b1ec5bfb890a7e71d93" name="ga81916c6a47f24b1ec5bfb890a7e71d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81916c6a47f24b1ec5bfb890a7e71d93">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator- for std::vector.</p>
<p >Perform the element-wise difference between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x - y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p >The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00466">466</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8b3c8bf3bd9204c55d991affed1bdfb0" name="ga8b3c8bf3bd9204c55d991affed1bdfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3c8bf3bd9204c55d991affed1bdfb0">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator-= for std::array.</p>
<p >Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p >The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::array, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00674">674</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga08fe06026beca2ceb67f0dceed31b531" name="ga08fe06026beca2ceb67f0dceed31b531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08fe06026beca2ceb67f0dceed31b531">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator-= for std::array.</p>
<p >Decrement each element in the input array, using the corresping value on the array at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p >The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00579">579</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga67fefa8b35f1f38d70c2dfff298346e5" name="ga67fefa8b35f1f38d70c2dfff298346e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67fefa8b35f1f38d70c2dfff298346e5">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator-= for std::array.</p>
<p >Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p >The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::array, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00617">617</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga59762030d80b896a612f791781fcd777" name="ga59762030d80b896a612f791781fcd777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59762030d80b896a612f791781fcd777">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator-= for std::vector.</p>
<p >Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p >The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::vector, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00662">662</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6c8ca10f1be3a4ef73728199de095951" name="ga6c8ca10f1be3a4ef73728199de095951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8ca10f1be3a4ef73728199de095951">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator-= for std::vector.</p>
<p >Decrement each element in the input vector, using the corresping value on vector at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p >The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00584">584</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga0ae2c7c7dd3909e0c79b00ad4f179d07" name="ga0ae2c7c7dd3909e0c79b00ad4f179d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae2c7c7dd3909e0c79b00ad4f179d07">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator-= for std::vector.</p>
<p >Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p >The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::vector, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00623">623</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac46faa02af5bf7ce75bbb1ba8b16cf16" name="gac46faa02af5bf7ce75bbb1ba8b16cf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac46faa02af5bf7ce75bbb1ba8b16cf16">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::array.</p>
<p >Perform the element-wise division between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if x[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01191">1191</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga1f1224ce75f96a1531fa86fa4365f725" name="ga1f1224ce75f96a1531fa86fa4365f725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1224ce75f96a1531fa86fa4365f725">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::array.</p>
<p >Perform the element-wise division between two arrays (x and y) and returns a array z s.t. z[i] = x[i] / y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01028">1028</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga571bed97e1f9dc43162ed05c86c7297f" name="ga571bed97e1f9dc43162ed05c86c7297f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571bed97e1f9dc43162ed05c86c7297f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::array.</p>
<p >Perform the element-wise division between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] / y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01067">1067</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gab73845b94584f17c7e810e27cba36f5d" name="gab73845b94584f17c7e810e27cba36f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73845b94584f17c7e810e27cba36f5d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::vector.</p>
<p >Perform the element-wise division between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if x[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01187">1187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga4d9d274530965b0fb1a331706535b2b0" name="ga4d9d274530965b0fb1a331706535b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9d274530965b0fb1a331706535b2b0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::vector.</p>
<p >Perform the element-wise division between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] / y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01020">1020</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9ee9c85d60d975df735a1c35fcf02e20" name="ga9ee9c85d60d975df735a1c35fcf02e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee9c85d60d975df735a1c35fcf02e20">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::vector.</p>
<p >Perform the element-wise division between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] / y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01060">1060</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b" name="gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8f9dc7bb4bcd6c7dfaf4bb48e6b32b">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::array.</p>
<p >Perform the element-wise division between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if y[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01151">1151</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga37768937a2c3d0c96284bd20f2799fc7" name="ga37768937a2c3d0c96284bd20f2799fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37768937a2c3d0c96284bd20f2799fc7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::array.</p>
<p >Perform the element-wise division between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x / y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01111">1111</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaaa8866a1e9873585704acfa8169ba1f4" name="gaaa8866a1e9873585704acfa8169ba1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8866a1e9873585704acfa8169ba1f4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::vector.</p>
<p >Perform the element-wise division between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if y[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01146">1146</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac6fff4de3b1f6cbedc8b80e0f29b673f" name="gac6fff4de3b1f6cbedc8b80e0f29b673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fff4de3b1f6cbedc8b80e0f29b673f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/ for std::vector.</p>
<p >Perform the element-wise division between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x / y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p >The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01105">1105</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga1edd77a9cc40f7e0640eeef310d60c32" name="ga1edd77a9cc40f7e0640eeef310d60c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edd77a9cc40f7e0640eeef310d60c32">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/= for std::array.</p>
<p >Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01291">1291</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga7b8622b683eb6d38f3ca2eee11f9045d" name="ga7b8622b683eb6d38f3ca2eee11f9045d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8622b683eb6d38f3ca2eee11f9045d">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/= for std::array.</p>
<p >Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01231">1231</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gadab7a46cda45f5c95e31e14b0cb2d44a" name="gadab7a46cda45f5c95e31e14b0cb2d44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab7a46cda45f5c95e31e14b0cb2d44a">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/= for std::array.</p>
<p >Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01261">1261</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga7d7471ac1e321cb428d90510d46edbc7" name="ga7d7471ac1e321cb428d90510d46edbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7471ac1e321cb428d90510d46edbc7">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/= for std::vector.</p>
<p >Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01307">1307</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9c760e4fb64cdc1b52bf2c589d77436e" name="ga9c760e4fb64cdc1b52bf2c589d77436e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c760e4fb64cdc1b52bf2c589d77436e">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/= for std::vector.</p>
<p >Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01229">1229</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9ac299c00791946cdbae7cdb8a54b3fc" name="ga9ac299c00791946cdbae7cdb8a54b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ac299c00791946cdbae7cdb8a54b3fc">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operator/= for std::vector.</p>
<p >Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p >The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01268">1268</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
</div><!-- contents -->

</div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Sun Jun 26 2022 16:17:56 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.3
</small></address>
    <div id="footer" >
        <div class="middle">
            <div class="box-wrapper">
                <div class="box bitpit">
                    <p>
                    <strong><a href="/bitpit">bitpit</a></strong><br />
                    <a href="/bitpit/modules/overview.html">Overview</a><br />
                    <a href="/bitpit/downloads">Downloads</a>
                    </p>
                </div>
                <div class="box optimad">
                    <p>
                    <strong><a href="http://www.optimad.it">OPTIMAD Engineering Srl</a></strong><br />
                    <a href="http://www.optimad.it/corporate/spin-off/">About</a><br />
                    <a href="http://www.optimad.it/contact-us/">Contact us</a><br />
                    <a href="mailto:info@optimad.it">info@optimad.it</a>
                    </p>
                </div>
                <div class="box address">
                    <p>
                    <strong>Address</strong><br />
                    Via Agostino da Montefeltro 2<br />
                    10134 Torino<br />
                    Italy
                    </p>
                </div>
                <div class="box info">
                    <p>
                    <strong>Info</strong><br />
                    Capitale Sociale  13.000,00 i.v.<br />
                    C.F. / P.Iva 09359170017<br />
                    Iscr. Reg. Impr. Torino - R.E.A. TO-1045102
                    </p>
                </div>
            </div>
        </div>
        <div class="legal">
            <p>
             2016-2021 OPTIMAD Engineering Srl  -  <a href="/bitpit/privacy.html">Privacy Policy</a>
            </p>
        </div>
    </div>
</div>
</body>
</html>
