
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="bitpit is a C++ library for scientific High Performance Computing." />
    <meta name="keywords" content="bitpit, HPC, octree, PABLO, levelset, RBF, mesh, grid" />
    <link rel="shortcut icon" href="/bitpit/images/bitpit.ico" type="image/x-icon">
    <link rel="icon" href="/bitpit/images/bitpit.ico" type="image/x-icon">
    <link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Lato:400,700'>
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/base.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/cookies.css" />
    <script type="text/javascript" src="/bitpit/scripts/jquery-1.12.4.min.js"></script>
    <script type="text/javascript" src="/bitpit/scripts/cookies.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-93686152-1', 'auto');
        ga('send', 'pageview');
    </script>
    <script type="text/javascript">
        $(document).ready(function(){
        });
    </script>
    <meta name="generator" content="Doxygen 1.8.14"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="manual.css" rel="stylesheet" type="text/css"/>
    <title>bitpit - Manual - Coding Style Guide</title>
</head>
<body>
<div id="cookie-warning">
        <p id="accept-cookies" class="button">Continue</p>
        <h3>Our website uses cookies</h3>
        <p>
        This website uses cookies. By continuing to use this website you are
        giving consent to cookies being used. For information on cookies
        and how you can disable them visit our
        <a href="/bitpit/privacy.html">Privacy Policy</a>.
        </p>
</div>
<!-- Header-->
<div id="header" class="">
    <div class="logo"><a href="/bitpit">&nbsp;</a></div>
    <div class="menu-line"></div>
<ul class="menu">
    <li>
        <a href="/bitpit/modules/index.html">Overview</a>
    </li>
    <li class="current">
        <span>Documentation</span>
        <ul class="sub-menu">
            <li><a href="/bitpit/documentation/installation.html">Installation guide</a></li>
            <li><a href="/bitpit/documentation/manual/1.5.0/index.html">Programmer's manual</a></li>
        </ul>
    </li>
    <li>
        <a href="/bitpit/downloads">Downloads</a>
    </li>
</ul>
<script type="text/javascript">
$('.menu li').hover(
    function() {
        $('ul', this).css('height', 'auto');
        $('ul', this).stop().slideDown(200);
    },
    function() {
        $('ul', this).stop().slideUp(200, function() {
            $(this).attr('style','');
        });
    }
);
</script>
</div>
<div id="content" class="">
<div id="manual">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Coding Style Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Code developed in <b>bitpit</b> should follow the coding styles described here. Any deviations from this style guide will result in severe berating and other verbal abuse.</p>
<h1><a class="anchor" id="directory_structure"></a>
bitpit Directory Structure</h1>
<p><b>bitpit</b> source code is organized in the following directory structure: <br />
</p><ul>
<li>doc: documentation is put here, along with the input file for Doxygen. Most <b>bitpit</b> documentation is doxygen-processed;</li>
<li>examples: examples of <b>bitpit</b> usage, both small and large. These programs are not meant to be used as unit tests, but rather as further documentation on <b>bitpit</b> usage;</li>
<li>src : source code;</li>
<li>test: all unit test programs should go below this directory.</li>
</ul>
<p>If you're designing a new class or other code for <b>bitpit</b> and are not sure where to put it, try to find something similar and put it there. Otherwise, email the <b>bitpit</b> email list for pointers. <br />
 </p>
<h1><a class="anchor" id="source_style"></a>
Source Code Style and Best Practices</h1>
<h2><a class="anchor" id="indentation"></a>
Indentation</h2>
<p>Use for indentation 4 characters.</p>
<p>The preferred way to ease multiple indentation levels in a switch statement is to align the "switch" and its subordinate "case" labels in the same column instead of "double-indenting" the "case" labels. E.g.: </p><div class="fragment"><div class="line">switch (suffix) {</div><div class="line">case &#39;G&#39;:</div><div class="line">case &#39;g&#39;:</div><div class="line">    mem &lt;&lt;= 30;</div><div class="line">    break;</div><div class="line">case &#39;M&#39;:</div><div class="line">case &#39;m&#39;:</div><div class="line">    mem &lt;&lt;= 20;</div><div class="line">    break;</div><div class="line">case &#39;K&#39;:</div><div class="line">case &#39;k&#39;:</div><div class="line">    mem &lt;&lt;= 10;</div><div class="line">    fall through</div><div class="line">default:</div><div class="line">    break;</div><div class="line">}</div></div><!-- fragment --><p> Don't put multiple statements on a single line unless you have something to hide: </p><div class="fragment"><div class="line">if (condition) do_this;</div><div class="line">  do_something_everytime;</div></div><!-- fragment --><p> Get a decent editor and don't leave whitespace at the end of lines.</p>
<h2><a class="anchor" id="bracing"></a>
Placing Braces</h2>
<p>The other issue that always comes up in C++ styling is the placement of braces. Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, as shown to us by the prophets Kernighan and Ritchie, is to put the opening brace last on the line, and put the closing brace first, thusly: </p><div class="fragment"><div class="line">if (x is true) {</div><div class="line">    we do y</div><div class="line">}</div></div><!-- fragment --><p> This applies to all non-function statement blocks (if, switch, for, while, do). E.g.: </p><div class="fragment"><div class="line">switch (action) {</div><div class="line">case KOBJ_ADD:</div><div class="line">    return &quot;add&quot;;</div><div class="line">case KOBJ_REMOVE:</div><div class="line">    return &quot;remove&quot;;</div><div class="line">case KOBJ_CHANGE:</div><div class="line">    return &quot;change&quot;;</div><div class="line">default:</div><div class="line">    return NULL;</div><div class="line">}</div></div><!-- fragment --><p> However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus: </p><div class="fragment"><div class="line">int function(int x)</div><div class="line">{</div><div class="line">    body of function</div><div class="line">}</div></div><!-- fragment --><p> Heretic people all over the world have claimed that this inconsistency is ... well ... inconsistent, but all right-thinking people know that (a) K&amp;R are <em>right</em> and (b) K&amp;R are right. Besides, functions are special anyway (you can't nest them in C++).</p>
<p>Note that the closing brace is empty on a line of its own, <em>except</em> in the cases where it is followed by a continuation of the same statement, i.e., a "while" in a do-statement or an "else" in an if-statement, like this: </p><div class="fragment"><div class="line">do {</div><div class="line">    body of do-loop</div><div class="line">} while (condition);</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">if (x == y) {</div><div class="line">    ..</div><div class="line">} else if (x &gt; y) {</div><div class="line">    ...</div><div class="line">} else {</div><div class="line">    ....</div><div class="line">}</div></div><!-- fragment --><p> Rationale: K&amp;R.</p>
<p>Also, note that this brace-placement also minimizes the number of empty (or almost empty) lines, without any loss of readability. Thus, as the supply of new-lines on your screen is not a renewable resource (think 25-line terminal screens here), you have more empty lines to put comments on.</p>
<p>Do not unnecessarily use braces where a single statement will do. </p><div class="fragment"><div class="line">if (condition)</div><div class="line">    action();</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">if (condition)</div><div class="line">    do_this();</div><div class="line">else</div><div class="line">    do_that();</div></div><!-- fragment --><p> This does not apply if only one branch of a conditional statement is a single statement; in the latter case use braces in both branches: </p><div class="fragment"><div class="line">if (condition) {</div><div class="line">    do_this();</div><div class="line">    do_that();</div><div class="line">} else {</div><div class="line">    otherwise();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="naming"></a>
Naming</h2>
<p>Class names should be in the CamelBack style, e.g. PatchCartesian or PatchOctree.</p>
<p>Class methods names should be in CamelBack style style but with a starting lower case letter, e.g. Patch::getId() or Interface::getArea().</p>
<p>Class private member variables should be in the CamelBack style and should have the prefix m_, e.g. PatchCartesian::m_cellSize. Each member variable that the user can modify, should have set/get functions, e.g. for the variable int m_variable it is necessary to define void setVariable(int newval) and int getVariable() const.</p>
<p>Enumeration values should be all captitalized, with underscores avoided if possible. The name of the enumeration name should be in the CamelBack style and indicates the general purpose of the enumeration, so e.g. we use Interface::PositionType, not Interface::InterfacePositionType.</p>
<p>No names should be added to the global namespace. Everything should be in the <b>bitpit</b> namespace. An exception can be made for names with a static scope declared in a .cpp file, but class member functions never have a static scope.</p>
<p>Names should be kept as private as possible. If declaring a struct or utility class that is used internally by some other class, consider defining it in the .cpp file of the main class or a separate header only included in that .cpp file and using (if necessary) only forward delcarations (e.g. <code>class</code> <code>Node</code>;) in the header file used by other code. If that is not possible, then consider nesting the definitions such that the scope of the name is limited to that of the class using it.</p>
<p>Any names introduced into the top-level <b>bitpit</b> namespace should be sufficiently unique to avoid conflicts with other code. If you must introduce a class to the top-level <b>bitpit</b> namespace, don't choose an overly genereric name like <code>Node</code>.</p>
<h2><a class="anchor" id="includes"></a>
Includes</h2>
<p>Developers should avoid using #include in header files, as they propagate dependencies more widely than necessary. The only cases where other includes are needed are to import the declaration for a parent class, and to declare types used as non-pointer and non-reference function arguments. In most cases, a forward-declaration statement (e.g. 'class Interface') will suffice.</p>
<h2><a class="anchor" id="constants-macros"></a>
Constants and Macros</h2>
<p>Don't use a pre-processor macro where a const variable or an inline or template function will suffice. There is absolutely benefit to the former over the later with modern compilers. Further, using macros bypasses typechecking that the compiler would otherwise do for you and if used in headers, introduce names into the global rather than <b>bitpit</b> namespace.</p>
<p>Don't define constants that are already provided by standard libraries.</p>
<h2><a class="anchor" id="typedefs"></a>
Typedefs</h2>
<p>Please don't use things like "vps_t". It's a <em>mistake</em> to use typedef for structures and pointers. When you see a </p><div class="fragment"><div class="line">vps_t a;</div></div><!-- fragment --><p> in the source, what does it mean? In contrast, if it says </p><div class="fragment"><div class="line">struct virtual_container *a;</div></div><!-- fragment --><p> you can actually tell what "a" is.</p>
<p>Lots of people think that typedefs "help readability". Not so. They are useful only for:</p>
<ul>
<li><p class="startli">totally opaque objects (where the typedef is actively used to <em>hide</em> what the object is).</p>
<p class="startli">Example: opaque objects that you can only access using the proper accessor functions.</p>
<p class="startli"><b>NOTE</b> Opaqueness and "accessor functions" are not good in themselves.</p>
</li>
<li><p class="startli">Clear integer types, where the abstraction <em>helps</em> avoid confusion whether it is "int" or "long".</p>
<p class="startli"><b>NOTE</b> Again - there needs to be a <em>reason</em> for this. If something is "unsigned long", then there's no reason to do </p><div class="fragment"><div class="line">typedef unsigned long myflags_t;</div></div><!-- fragment --><p> but if there is a clear reason for why it under certain circumstances might be an "unsigned int" and under other configurations might be "unsigned long", then by all means go ahead and use a typedef.</p>
</li>
<li>when you use sparse to literally create a <em>new</em> type for type-checking.</li>
<li><p class="startli">New types which are identical to standard types, in certain exceptional circumstances.</p>
<p class="startli">Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like 'uint32_t', some people object to their use anyway.</p>
<p class="startli">When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code.</p>
</li>
</ul>
<p>Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules.</p>
<p>In general, a pointer, or a struct that has elements that can reasonably be directly accessed should <em>never</em> be a typedef.</p>
<h2><a class="anchor" id="functions"></a>
Functions</h2>
<p>Functions should be short and sweet, and do just one thing. They should fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we all know), and do one thing and do that well.</p>
<p>The maximum length of a function is inversely proportional to the complexity and indentation level of that function. So, if you have a conceptually simple function that is just one long (but simple) case-statement, where you have to do lots of small things for a lot of different cases, it's OK to have a longer function.</p>
<p>However, if you have a complex function, and you suspect that a less-than-gifted first-year high-school student might not even understand what the function is all about, you should adhere to the maximum limits all the more closely. Use helper functions with descriptive names (you can ask the compiler to in-line them if you think it's performance-critical, and it will probably do a better job of it than you would have done).</p>
<p>Another measure of the function is the number of local variables. They shouldn't exceed 5-10, or you're doing something wrong. Re-think the function, and split it into smaller pieces. A human brain can generally easily keep track of about 7 different things, anything more and it gets confused. You know you're brilliant, but maybe you'd like to understand what you did 2 weeks from now.</p>
<p>In source files, separate functions with one blank line.</p>
<p>In function prototypes, include parameter names with their data types. Although this is not required by the C++ language, it is preferred because it is a simple way to add valuable information for the reader.</p>
<h2><a class="anchor" id="exit-functions"></a>
Centralized exiting of functions</h2>
<p>Albeit deprecated by some people, the equivalent of the goto statement is used frequently by compilers in form of the unconditional jump instruction.</p>
<p>The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done. If there is no cleanup needed then just return directly.</p>
<p>Choose label names which say what the goto does or why the goto exists. An example of a good name could be "out_buffer:" if the goto frees "buffer". Avoid using GW-BASIC names like "err1:" and "err2:". Also don't name them after the goto location like "err_kmalloc_failed:"</p>
<p>The rationale for using gotos is:</p>
<ul>
<li>unconditional statements are easier to understand and follow</li>
<li>nesting is reduced</li>
<li>errors by not updating individual exit points when making modifications are prevented</li>
<li>saves the compiler work to optimize redundant code away ;) <div class="fragment"><div class="line">int fun(int a)</div><div class="line">{</div><div class="line">    int result = 0;</div><div class="line">    char *buffer;</div><div class="line"></div><div class="line">    buffer = kmalloc(SIZE, GFP_KERNEL);</div><div class="line">    if (!buffer)</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    if (condition1) {</div><div class="line">        while (loop1) {</div><div class="line">            ...</div><div class="line">        }</div><div class="line">        result = 1;</div><div class="line">        goto out_buffer;</div><div class="line">    }</div><div class="line">    ...</div><div class="line">out_buffer:</div><div class="line">    kfree(buffer);</div><div class="line">    return result;</div><div class="line">}</div></div><!-- fragment --> A common type of bug to be aware of it "one err bugs" which look like this: <div class="fragment"><div class="line">err:</div><div class="line">    kfree(foo-&gt;bar);</div><div class="line">    kfree(foo);</div><div class="line">    return ret;</div></div><!-- fragment --> The bug in this code is that on some exit paths "foo" is NULL. Normally the fix for this is to split it up into two error labels "err_bar:" and "err_foo:".</li>
</ul>
<h2><a class="anchor" id="function-return-values"></a>
Function return values</h2>
<p>Functions can return values of many different kinds, and one of the most common is a value indicating whether the function succeeded or failed. Such a value can be represented as an error-code integer (-Exxx = failure, 0 = success) or a "succeeded" boolean (0 = failure, non-zero = success).</p>
<p>Mixing up these two sorts of representations is a fertile source of difficult-to-find bugs. To help prevent such bugs, always follow this convention: </p><pre class="fragment">If the name of a function is an action or an imperative command,
the function should return an error-code integer.  If the name
is a predicate, the function should return a "succeeded" boolean.
</pre><p>For example, "add work" is a command, and the add_work() function returns 0 for success or -EBUSY for failure. In the same way, "PCI device present" is a predicate, and the pci_dev_present() function returns 1 if it succeeds in finding a matching device or 0 if it doesn't.</p>
<p>All public functions must respect this convention. Private (static) functions need not, but it is recommended that they do.</p>
<p>Functions whose return value is the actual result of a computation, rather than an indication of whether the computation succeeded, are not subject to this rule. Generally they indicate failure by returning some out-of-range result. Typical examples would be functions that return pointers; they use NULL to report failure.</p>
<h2><a class="anchor" id="inline"></a>
The inline disease</h2>
<p>There appears to be a common misperception that gcc has a magic "make me
faster" speedup option called "inline". While the use of inlines can be appropriate (for example as a means of replacing macros), it very often is not. Abundant use of the inline keyword leads to a much bigger executable, which in turn slows the program as a whole down, due to a bigger icache footprint for the CPU and simply because there is less memory available for the pagecache. Just think about it; a pagecache miss causes a disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles that can go into these 5 milliseconds.</p>
<p>A reasonable rule of thumb is to not put inline at functions that have more than 3 lines of code in them. An exception to this rule are the cases where a parameter is known to be a compiletime constant, and as a result of this constantness you <em>know</em> the compiler will be able to optimize most of your function away at compile time.</p>
<p>Often people argue that adding inline to functions that are static and used only once is always a win since there is no space tradeoff. While this is technically correct, gcc is capable of inlining these automatically without help, and the maintenance issue of removing the inline when a second user appears outweighs the potential value of the hint that tells gcc to do something it would have done anyway.</p>
<h2><a class="anchor" id="conditional-compilation"></a>
Conditional Compilation</h2>
<p>Wherever possible, don't use preprocessor conditionals (#if, #ifdef) in .c files; doing so makes code harder to read and logic harder to follow. Instead, use such conditionals in a header file defining functions for use in those .c files, providing no-op stub versions in the #else case, and then call those functions unconditionally from .c files. The compiler will avoid generating any code for the stub calls, producing identical results, but the logic will remain easy to follow.</p>
<p>Prefer to compile out entire functions, rather than portions of functions or portions of expressions. Rather than putting an ifdef in an expression, factor out part or all of the expression into a separate helper function and apply the conditional to that function.</p>
<p>If you have a function or variable which may potentially go unused in a particular configuration, and the compiler would warn about its definition going unused, mark the definition as __maybe_unused rather than wrapping it in a preprocessor conditional. (However, if a function or variable <em>always</em> goes unused, delete it.)</p>
<p>At the end of any non-trivial #if or #ifdef block (more than a few lines), place a comment after the #endif on the same line, noting the conditional expression used. For instance: </p><div class="fragment"><div class="line">#ifdef CONFIG_SOMETHING</div><div class="line">...</div><div class="line">#endif // CONFIG_SOMETHING</div></div><!-- fragment --><h2><a class="anchor" id="commenting"></a>
Commenting</h2>
<p>Comments are good, but there is also a danger of over-commenting. NEVER try to explain HOW your code works in a comment: it's much better to write the code so that the <em>working</em> is obvious, and it's a waste of time to explain badly written code.</p>
<p>Generally, you want your comments to tell WHAT your code does, not HOW. Also, try to avoid putting comments inside a function body: if the function is so complex that you need to separately comment parts of it, you should probably split the function into smaller functions. You can make small comments to note or warn about something particularly clever (or ugly), but try to avoid excess. Instead, put the comments at the head of the function, telling people what it does, and possibly WHY it does it.</p>
<p>Try to keep header files free of comments; when comments are inside headers, all users of those headers must be recompiled if a comment is changed.</p>
<p>Each class should be fully commented with a doxygen comment block. A doxygen comment block is a special comment block with some additional markings, so doxygen knows it is a piece of structured text that needs to end up in the generated documentation. The preferred way to mark a doxygen comment block is the JavaDoc style, which consist of a C-style comment block starting with two *'s, like this: </p><pre class="fragment">    \**
    * ... text ...
    */
</pre><p> The doxygen comment block of a class should include a general description of the class and a list of its features and possible limitations.</p>
<p>A doxygen comment block should be added for every method of a class (both public and private methos should be commented), this comment block should contain a general description of the method and a description of all the arguments and the return value of the method. For instance: </p><pre class="fragment">    /**
    * \brief Brief description.
    *        Brief description continued.
    *
    *  Detailed description starts here.
    *
    *  \param var detailed description of the parameter
    *  \result Detailed description of the return value.
    */
</pre><p>To document the members of a file, struct, union, class, or enum, it is sometimes desired to place the documentation block after the member instead of before. For this purpose an additional &lt; marker is required in the comment block. Note that this also works for the parameters of a function. For instance: </p><pre class="fragment">    int var; /**&lt; Detailed description after the member */
</pre><p> To simplify the documentation of class members, define just one member per line (no commas for multiple members declarations).</p>
<p>Doxygen commands should start with a backslash (\).</p>
<p>As a rule of thumb, the code should run through doxygen without generating any warnings; in fact, doxygen is sometimes helpful at pointing out inconsistencies in your class declaration.</p>
<h1><a class="anchor" id="git"></a>
Git Repository Practices</h1>
<p>As most of our code repositories uses git as the revision control system, it is important to decide on a workflow that can be followed by the individual developer. The way that any individual developer interact with the upstream git repository can have an important impact on other developers and the ability to identify and manage individual changes. This set of guidelines and practices attempts to establish some standards for how developers will interact with the upstream git repository.</p>
<h2><a class="anchor" id="commits"></a>
Making Repository Commits</h2>
<p>As a general rule, developers should update frequently, and commit changes often. However, the repository should always remain in a state where the code can be compiled. Most of the time, the code should also successfully execute "make check" run from the top-level directory. If you commit code that violates this principal, it should be your first priority to return the repository code to a compilable state, and your second priority to make sure "make check" runs without errors. Although it would be possible and many software projects do it, we prefer not to force successful execution of the test suite before every commit. Developers should make every effort to avoid having to impose this constraint, by running a make check before every commit.</p>
<p>Commits to the repository should also come with a non-trivial and useful log message.</p>
<h2><a class="anchor" id="outside-master"></a>
Working Outside the Master Branch</h2>
<p>A critical concept is that all changes shall be developed outside of the master<sup>1</sup> branch. Whether they are in a different branch of the upstream<sup>2</sup> repository (gitflow) or a branch of an entirely different fork (forking workflow) is secondary. This is a well-established concept regardless of the workflow being adopted, and allows a number of other benefits as described below.</p>
<h3><a class="anchor" id="fork"></a>
Working on a Different Fork</h3>
<p>There are a number of benefits of working on a different fork rather than a branch of the upstream repo, although not strictly technical:</p><ul>
<li>Developers, particularly new developers, are liberated from the constant oversight of others as they explore new code options. The impact of this may depend on an individual developer’s personality, but for some it creates a refuge where they can be more free and creative.</li>
<li>Similarly, assuming that all changesets in the upstream repo are communicated to the entire development team, the team is spared a noisy stream of notifications and can focus their attention on the rarer occurrence of a pull request notification.</li>
</ul>
<h3><a class="anchor" id="pr"></a>
All Changes are Committed by Pull Request</h3>
<p>Although this can be imposed technically by limiting the authority to alter the upstream repo (as in the forking workflow), a healthy developer community can also simply rely on convention. The advantage of doing it by convention rather than by restriction is that it is easier to distribute the load of reviewing and accepting changes. A critical consequence of this decision is that all code is reviewed before it is committed to the upstream master branch. This has benefits to overall quality in two related ways:</p><ul>
<li>the code under review will improve due to the review itself, and</li>
<li>those involved in the review will maintain a broad awareness of the code base resulting in better contributions from them.</li>
</ul>
<p>This practice does, however, place a substantial burden on the developers to perform timely reviews of the pull requested (PR’ed) code. PR’s that languish without sufficient review have a number of negative consequences:</p><ul>
<li>they need to be refreshed simply to keep them up-to-date with the possibly advancing upstream/master</li>
<li>they may delay further development on similar or related features</li>
<li>they breed frustration in the original developer, undermining the community as a whole. github provides powerful collaboration tools that greatly facilitate this process.</li>
</ul>
<p><sup>1</sup> Although a repository may choose a different name for its main development branch, this document will refer to that as the “master” branch.</p>
<p><sup>2</sup> For this discussion, the “upstream” repo will refer to the centralized authoritative repository used to synchronize changes.</p>
<h2><a class="anchor" id="git-mechanics"></a>
Some Git Mechanics to Keep it Clean</h2>
<p>Given the above practices, there are some mechanical details that can help ensure that the upstream/master repository is always in a state that facilitates all repository actions and interactions.</p>
<ol type="1">
<li><p class="startli">Feature branches being used for development should be kept up-to-date with the upstream/master by rebase only. When a feature branch is rebased against the upstream/master, all changes in the upstream/master are inserted into the feature branch at a point in its history that is prior to any of the changes of the feature branch. This can require conflict resultion as the feature branch changes are “replayed” on top of the new upstream/master in its current state. The primary advantage of this policy is that it keeps all of the feature branch changes contiguous. If, by contrast, the upstream/master is merged into the feature branch, the recent changes in the upstream/master become woven into the set of changes in the feature branch. This can make it more difficult to isolate changes later on.</p>
<p class="startli">Strict adoption of this practice is important since a single merge into a feature branch that is then merged back into the upstream/master can make it nearly impossible for others to rebase.</p>
<p class="startli">A typical workflow with pull-request might look like this, all using the command-line, except for submitting the final pull request. Note that there is never a merge operation.</p><ol type="a">
<li>synchronize your local <code>master</code> branch before anything else <div class="fragment"><div class="line">$ git checkout master</div><div class="line">$ git fetch upstream</div><div class="line">$ git rebase upstream/master</div></div><!-- fragment --></li>
<li>now create a new feature branch from master <div class="fragment"><div class="line">$ git checkout -b my_feature_branch master</div></div><!-- fragment --></li>
<li>now make changes, editing A.cpp, B.hpp, C.cpp</li>
<li>now add/commit your changes to your local feature branch <div class="fragment"><div class="line">$ git add A.cpp B.hpp C.cpp</div><div class="line">$ git commit -m “Make sure you have a good commit message”</div></div><!-- fragment --></li>
<li>push your changes to your feature branch on your fork (often called <code>origin</code>) <div class="fragment"><div class="line">$ git push origin my_feature_branch</div></div><!-- fragment --></li>
<li>make more changes, editing B.hpp, D.hpp, E.cpp</li>
<li>add/commit your changes to your local feature branch <div class="fragment"><div class="line">$ git add B.hpp D.hpp E.cpp</div><div class="line">$ git commit -m “Be sure you have another good commit message”</div></div><!-- fragment --></li>
<li>push your changes to your freature branch on your fork (often called <code>origin</code>) <div class="fragment"><div class="line">$ git push origin my_feature_ranch</div></div><!-- fragment --></li>
<li><p class="startli">When you are ready to submit a pull request, be sure that your feature branch is up-to-date. This first step may seem redundant but is here to be clear which branch we are acting on </p><div class="fragment"><div class="line">$ git checkout my_feature_branch</div><div class="line">$ git fetch upstream</div><div class="line">$ git rebase upstream/master</div></div><!-- fragment --><p> This may generate conflicts that can be addressed at this point.</p>
<p class="startli">NOTE: This step can be performed at any time and should be performed as often as practical to reduce the scope of potential conflicts.</p>
</li>
<li>push your updated feature branch on your fork (often called <code>origin</code>) <div class="fragment"><div class="line">$ git push origin my_feature_branch</div></div><!-- fragment --> This may require the ‘-f’ option to force the push. (It is frequently necessary to force this push because the act of rebasing will “replay” the commits from the feature branch on top of the master, leading to different commit hashes. Each of the commits will contain the same actual information, but because it has a different set of hashes, git will think there is an inconsistency and ask you to force the change.)</li>
<li>Submit a pull request on github, from your fork to the fathomteam fork.</li>
</ol>
</li>
<li><p class="startli">When ready to be adopted into the upstream/master, feature branches should be combined by merge only. This adds the changeset to the end of the upstream/master as a set of individual commits but in a contiguous block.</p>
<p class="startli">A typical workflow to merge a pull-request might look like this, all using the command-line.</p><ol type="a">
<li>synchronize your local <code>master</code> branch before anything else (just because it’s never a bad idea!) <div class="fragment"><div class="line">$ git checkout master</div><div class="line">$ git fetch upstream</div><div class="line">$ git rebase upstream/master</div></div><!-- fragment --></li>
<li>add a remote for the user with the pull-request, perhaps the user is ‘other_user’ <div class="fragment"><div class="line">$ git remote add other_user \</div><div class="line">      git@bitbucket.org:other_user/moab.git</div></div><!-- fragment --></li>
<li>fetch the other users repo <div class="fragment"><div class="line">$ git fetch other_user</div></div><!-- fragment --></li>
<li>check out their feature branch <div class="fragment"><div class="line">$ git checkout -b pr_feature_branch \</div><div class="line">    other_user/feature_branch</div></div><!-- fragment --></li>
<li>confirm that it is up-to-date with the master. This first step may seem redundant but is here to be clear which branch we are acting on <div class="fragment"><div class="line">$ git checkout pr_feature_branch</div><div class="line">$ git fetch upstream</div><div class="line">$ git rebase upstream/master</div></div><!-- fragment --> This may generate conflicts that can be addressed at this point. You may want to request the original author (other_user) take care of these.</li>
<li>once confirmed that it’s up-to-date with master, review this branch including: -reading the code -building the code -running tests</li>
<li>once satisfied that the code meets the necessary standards and that all required/requested changes are fully incorporated into other_users’s feature branch, merge it into master <div class="fragment"><div class="line">$ git checkout master</div></div><!-- fragment --> The next two steps may seem redundant but provide some QA <div class="fragment"><div class="line">$ git fetch upstream</div><div class="line">$ git rebase upstream/master</div><div class="line">$ git merge other_user/feature_branch</div></div><!-- fragment --></li>
<li>push those changes into the master branch on bitbucket <div class="fragment"><div class="line">$ git push upstream/master</div></div><!-- fragment --></li>
</ol>
</li>
<li>When a pull request is open for review, any changes to the feature branch will automatically update the pull request. This is the appropriate way for a developer to respond to requests for changes that occur through the PR process.</li>
<li>If a developer has ongoing work that is based on a feature branch that is under consideration in an open PR, a new feature branch (B) should be created that is based on the previous feature branch (A). Moreover, as changes are made to the original feature branch (A) due to the review process, the new feature branch (B) should be kept up-to-date by rebase against feature branch (A). This keeps all subsequent changes of (B) downstream from the changes in (A). Once feature branch (A) has been adopted into the upstream/master, the new feature branch (B) can start being rebased against the upstream/master instead.</li>
<li>When a repo is forked, its branches are not automatically synchronized with the corresponding branches on the upstream repo. This requires a manual process of synchronization via a local clone. Assuming that the local repo’s branch has the same name as the upstream branch (&lt;branch&gt;), and that the fork is known as “origin”: <div class="fragment"><div class="line">$ git fetch upstream</div><div class="line">$ git checkout &lt;branch&gt;</div><div class="line">$ git rebase upstream/&lt;branch&gt;</div><div class="line">$ git push origin &lt;branch&gt;</div></div><!-- fragment --> The decision of which branches to keep up-to-date is up to the developers. Developers may choose to delete some branches from their own fork to avoid (a) the need to update it and (b) accidentally assuming that it is up-to-date.</li>
<li>When rebasing, it is not uncommon to encounter conflicts. This will interrupt the rebasing process, and each conflicted file will contain conflict blocks. You will be offered three choices:<ul>
<li>manually resolve the conflicts, add the resolved files with git add, and then git rebase &ndash;continue (do not commit the resolved files!)</li>
<li>abort the rebasing process entirely with git rebase &ndash;abort</li>
<li>skip the commit that causes the conflict, assuming that you are sure that this is the right thing to do, with git rebase &ndash;skip</li>
</ul>
</li>
<li>github offers a number of buttons/tools to manage changes between branches and forks. Some of these operate in ways that are contrary to the practices recommended here, and others are consistent with these practices. In general, it is best to know how to do all of those operations with the command-line instead of relying on github, as it gives you full control over important details.</li>
<li>During code development, it might be necessary to work on the same branch on different machines. The workflow to update the local branch is to first fetch the remote changes and then perform a hard reset. <div class="fragment"><div class="line">$ git fetch origin</div><div class="line">$ git reset --hard origin/branch_name</div></div><!-- fragment --> One should be careful with the branch name as a hard reset would overwrite all changes in the working directory.</li>
</ol>
<p>Top: <a class="el" href="styleguide.html">Coding Style Guide</a> </p>
</div></div><!-- contents -->

</div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Fri Aug 10 2018 23:06:24 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
    <div id="footer" >
        <div class="middle">
            <div class="box-wrapper">
                <div class="box bitpit">
                    <p>
                    <strong><a href="/bitpit">bitpit</a></strong><br />
                    <a href="/bitpit/modules/overview.html">Overview</a><br />
                    <a href="/bitpit/downloads">Downloads</a>
                    </p>
                </div>
                <div class="box optimad">
                    <p>
                    <strong><a href="http://www.optimad.it">OPTIMAD Engineering Srl</a></strong><br />
                    <a href="http://www.optimad.it/corporate/spin-off/">About</a><br />
                    <a href="http://www.optimad.it/contact-us/">Contact us</a><br />
                    <a href="mailto:info@optimad.it">info@optimad.it</a>
                    </p>
                </div>
                <div class="box address">
                    <p>
                    <strong>Address</strong><br />
                    Via Giacinto Collegno 18<br />
                    10143 Torino<br />
                    Italy
                    </p>
                </div>
                <div class="box info">
                    <p>
                    <strong>Info</strong><br />
                    Capitale Sociale € 10.000,00 i.v.<br />
                    C.F. / P.Iva 09359170017<br />
                    Iscr. Reg. Impr. Torino - R.E.A. TO-1045102
                    </p>
                </div>
            </div>
        </div>
        <div class="legal">
            <p>
            © 2016-2018 OPTIMAD Engineering Srl  -  <a href="/bitpit/privacy.html">Privacy Policy</a>
            </p>
        </div>
    </div>
</div>
</body>
</html>
