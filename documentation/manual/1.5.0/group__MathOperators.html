
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="bitpit is a C++ library for scientific High Performance Computing." />
    <meta name="keywords" content="bitpit, HPC, octree, PABLO, levelset, RBF, mesh, grid" />
    <link rel="shortcut icon" href="/bitpit/images/bitpit.ico" type="image/x-icon">
    <link rel="icon" href="/bitpit/images/bitpit.ico" type="image/x-icon">
    <link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Lato:400,700'>
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/base.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit/stylesheets/cookies.css" />
    <script type="text/javascript" src="/bitpit/scripts/jquery-1.12.4.min.js"></script>
    <script type="text/javascript" src="/bitpit/scripts/cookies.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-93686152-1', 'auto');
        ga('send', 'pageview');
    </script>
    <script type="text/javascript">
        $(document).ready(function(){
        });
    </script>
    <meta name="generator" content="Doxygen 1.8.14"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="manual.css" rel="stylesheet" type="text/css"/>
    <title>bitpit - Manual - Mathematical Operators</title>
</head>
<body>
<div id="cookie-warning">
        <p id="accept-cookies" class="button">Continue</p>
        <h3>Our website uses cookies</h3>
        <p>
        This website uses cookies. By continuing to use this website you are
        giving consent to cookies being used. For information on cookies
        and how you can disable them visit our
        <a href="/bitpit/privacy.html">Privacy Policy</a>.
        </p>
</div>
<!-- Header-->
<div id="header" class="">
    <div class="logo"><a href="/bitpit">&nbsp;</a></div>
    <div class="menu-line"></div>
<ul class="menu">
    <li>
        <a href="/bitpit/modules/index.html">Overview</a>
    </li>
    <li class="current">
        <span>Documentation</span>
        <ul class="sub-menu">
            <li><a href="/bitpit/documentation/installation.html">Installation guide</a></li>
            <li><a href="/bitpit/documentation/manual/1.5.0/index.html">Programmer's manual</a></li>
        </ul>
    </li>
    <li>
        <a href="/bitpit/downloads">Downloads</a>
    </li>
</ul>
<script type="text/javascript">
$('.menu li').hover(
    function() {
        $('ul', this).css('height', 'auto');
        $('ul', this).stop().slideDown(200);
    },
    function() {
        $('ul', this).stop().slideUp(200, function() {
            $(this).attr('style','');
        });
    }
);
</script>
</div>
<div id="content" class="">
<div id="manual">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Mathematical Operators<div class="ingroups"><a class="el" href="group__OperatorsFunctions.html">Operators and Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mathematical Operators:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__MathOperators.png" border="0" alt="" usemap="#group____MathOperators"/>
<map name="group____MathOperators" id="group____MathOperators">
<area shape="rect" id="node2" href="group__OperatorsFunctions.html" title="Operators and Functions" alt="" coords="5,5,175,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="memitem:ga3f635ef98b56435afb45a039abf9e039"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3f635ef98b56435afb45a039abf9e039"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3f635ef98b56435afb45a039abf9e039">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3f635ef98b56435afb45a039abf9e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7017c5d06814ac672157b881cc29f086"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga7017c5d06814ac672157b881cc29f086"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga7017c5d06814ac672157b881cc29f086">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7017c5d06814ac672157b881cc29f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga44d22adb8eb80a55b5379bbc4bcb9422">operator+</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba4d31507040c35f062537329b2f99d"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga3ba4d31507040c35f062537329b2f99d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3ba4d31507040c35f062537329b2f99d">operator+</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3ba4d31507040c35f062537329b2f99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga46ab5d3f2416d30ad6ed556e513ca15e">operator+</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga71c4e0f1fa74771e27be330e94c98fa1">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga0753f57c13e8860d7d89a3c1d38c2f73">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6d4f03731e627c861ab285e02d00f7ff">operator+=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da48a189e6261dbea01a0042d36a814"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1da48a189e6261dbea01a0042d36a814"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga1da48a189e6261dbea01a0042d36a814">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1da48a189e6261dbea01a0042d36a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af61c1b7033247df0338ccce0e612d6"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3af61c1b7033247df0338ccce0e612d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3af61c1b7033247df0338ccce0e612d6">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga3af61c1b7033247df0338ccce0e612d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579c90a19cace79621439edbc2d4a73b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga579c90a19cace79621439edbc2d4a73b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga579c90a19cace79621439edbc2d4a73b">operator-</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga579c90a19cace79621439edbc2d4a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga458d5cb02f35f9a5d5bb4ec188ff7df9">operator-</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8afe15fc58c619bd07278b1b2bc1fba9">operator-</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07c4511ff8846e22d929bdefc82cd46"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gae07c4511ff8846e22d929bdefc82cd46"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae07c4511ff8846e22d929bdefc82cd46">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gae07c4511ff8846e22d929bdefc82cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e0e282c16ff506763346bbabbb27a2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga98e0e282c16ff506763346bbabbb27a2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga98e0e282c16ff506763346bbabbb27a2">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga98e0e282c16ff506763346bbabbb27a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea724ee1533cefef0eeb081a124145f2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaea724ee1533cefef0eeb081a124145f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaea724ee1533cefef0eeb081a124145f2">operator-=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaea724ee1533cefef0eeb081a124145f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga1d7733125c27824e1aa57ebae04b06a8">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4462ec066ada6e0be6054a50670510b9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga4462ec066ada6e0be6054a50670510b9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4462ec066ada6e0be6054a50670510b9">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga4462ec066ada6e0be6054a50670510b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c63fae35933caafc7d747052b96b2f2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga6c63fae35933caafc7d747052b96b2f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6c63fae35933caafc7d747052b96b2f2">operator*</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga6c63fae35933caafc7d747052b96b2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga04c59fa6da7fc1146dac00e02084d5d6">operator*</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873023bbde7c283db20e88467cabf3d3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga873023bbde7c283db20e88467cabf3d3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga873023bbde7c283db20e88467cabf3d3">operator*</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga873023bbde7c283db20e88467cabf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0292340505d2a22841ce7b8960345b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gace0292340505d2a22841ce7b8960345b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gace0292340505d2a22841ce7b8960345b">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gace0292340505d2a22841ce7b8960345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaa3a09d793370ba100f19a3af3ec567a4">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae4182cfb7e85ce1cf28603be3ea64891">operator*=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaf48b3511fe629a19ad6d343b3722b18f">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5d819f94a4f2c54f683086dfd60914fe">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f1060376be7df1fdfaf5372216bb03"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga17f1060376be7df1fdfaf5372216bb03"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga17f1060376be7df1fdfaf5372216bb03">operator/</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga17f1060376be7df1fdfaf5372216bb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaa5db31c5d90112637e4d2fa84eee9d7e">operator/</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb62dde4f70707cef0988601e7ae3c08"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gabb62dde4f70707cef0988601e7ae3c08"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gabb62dde4f70707cef0988601e7ae3c08">operator/</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gabb62dde4f70707cef0988601e7ae3c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86745bdc619c80a87b7495a2be35b5be"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga86745bdc619c80a87b7495a2be35b5be"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga86745bdc619c80a87b7495a2be35b5be">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga86745bdc619c80a87b7495a2be35b5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7c612383329df772db1f49839fea19"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga5b7c612383329df772db1f49839fea19"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5b7c612383329df772db1f49839fea19">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5b7c612383329df772db1f49839fea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50403f99e949516bedf459d21540353c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga50403f99e949516bedf459d21540353c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga50403f99e949516bedf459d21540353c">operator/=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga50403f99e949516bedf459d21540353c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga71b722bb9670854ddfcb0e867620083f">operator+</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga71b722bb9670854ddfcb0e867620083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga97948a906b46303c7c654c84149dd9ee">operator+</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga97948a906b46303c7c654c84149dd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gade9e3b35c5ed9d228bd242eaee48df2f">operator+</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga06cb1fde86b09befdc0b42d99fdbf31f">operator+</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6e163effd6e58c7f726fbd29f5c1e42c">operator+</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4a54e162a0893a716a8e767bccc5bcf6">operator+=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043993b9b79a9ae8c6311907bf739c83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043993b9b79a9ae8c6311907bf739c83"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga043993b9b79a9ae8c6311907bf739c83">operator+=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043993b9b79a9ae8c6311907bf739c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaf7b6c9177a03b67eb4d3746d11295984">operator+=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga39b3f7b4938cab605085cc4a2621c0c1">operator-</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8b14f28bd4c6544e7af363162827a3f9">operator-</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga81916c6a47f24b1ec5bfb890a7e71d93">operator-</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gacd869d6ee14d5683b3fa4fcefc5ae5fa">operator-</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga043799b065672b453653cccc836df3e0">operator-</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043799b065672b453653cccc836df3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aacb9fe943aadde419e168ee051f35f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0aacb9fe943aadde419e168ee051f35f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga0aacb9fe943aadde419e168ee051f35f">operator-=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga0aacb9fe943aadde419e168ee051f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2595b252e76781008f28f0d4259abd6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac2595b252e76781008f28f0d4259abd6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac2595b252e76781008f28f0d4259abd6">operator-=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac2595b252e76781008f28f0d4259abd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8734f21e1ba10ab0e30ca2d98ac458c7">operator-=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga2bd9e5a66f35bd5cfe4903f2405c87ba">operator*</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac44d2a365e67d48fc144cf576f4e003e">operator*</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac44d2a365e67d48fc144cf576f4e003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga92fa8968855d071e34808339503fe37b">operator*</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga92fa8968855d071e34808339503fe37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae5c14d292d187b6a76d4acd8068e2ec3">operator*</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5be9b506ad98c26a66c46e3a63569af2">operator*</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e59ed744d940c52f17237762edeb63"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga53e59ed744d940c52f17237762edeb63"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga53e59ed744d940c52f17237762edeb63">operator*=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga53e59ed744d940c52f17237762edeb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga7bb44d4987361a698f36b0b43da90ec7">operator*=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga56a1b2553cf1c204e208ddf55fdfbff0">operator*=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4d9d274530965b0fb1a331706535b2b0">operator/</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4d9d274530965b0fb1a331706535b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga9ee9c85d60d975df735a1c35fcf02e20">operator/</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac6fff4de3b1f6cbedc8b80e0f29b673f">operator/</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaaa8866a1e9873585704acfa8169ba1f4">operator/</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gab73845b94584f17c7e810e27cba36f5d">operator/</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab73845b94584f17c7e810e27cba36f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gabef2e8a23bc01ea9a02f8478705a8055">operator/=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c760c866b18096f41015d84c1ba517"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad1c760c866b18096f41015d84c1ba517"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gad1c760c866b18096f41015d84c1ba517">operator/=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gad1c760c866b18096f41015d84c1ba517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661186ca419d7b771ea549dc2bee4229"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga661186ca419d7b771ea549dc2bee4229"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga661186ca419d7b771ea549dc2bee4229">operator/=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga661186ca419d7b771ea549dc2bee4229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2bd9e5a66f35bd5cfe4903f2405c87ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd9e5a66f35bd5cfe4903f2405c87ba">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] * y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00703">703</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga1d7733125c27824e1aa57ebae04b06a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7733125c27824e1aa57ebae04b06a8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between two arrays (x and y) and returns a array z s.t. z[i] = x[i] * y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00715">715</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gac44d2a365e67d48fc144cf576f4e003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44d2a365e67d48fc144cf576f4e003e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] * y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00743">743</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga4462ec066ada6e0be6054a50670510b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4462ec066ada6e0be6054a50670510b9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] * y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00754">754</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga92fa8968855d071e34808339503fe37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92fa8968855d071e34808339503fe37b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x * y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00783">783</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6c63fae35933caafc7d747052b96b2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c63fae35933caafc7d747052b96b2f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x * y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00793">793</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gae5c14d292d187b6a76d4acd8068e2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c14d292d187b6a76d4acd8068e2ec3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00821">821</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga04c59fa6da7fc1146dac00e02084d5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04c59fa6da7fc1146dac00e02084d5d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::array, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00831">831</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5be9b506ad98c26a66c46e3a63569af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be9b506ad98c26a66c46e3a63569af2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00862">862</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga873023bbde7c283db20e88467cabf3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873023bbde7c283db20e88467cabf3d3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::array, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00871">871</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga53e59ed744d940c52f17237762edeb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e59ed744d940c52f17237762edeb63">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00901">901</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gace0292340505d2a22841ce7b8960345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0292340505d2a22841ce7b8960345b">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00911">911</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga7bb44d4987361a698f36b0b43da90ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb44d4987361a698f36b0b43da90ec7">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00940">940</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaa3a09d793370ba100f19a3af3ec567a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3a09d793370ba100f19a3af3ec567a4">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00949">949</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga56a1b2553cf1c204e208ddf55fdfbff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a1b2553cf1c204e208ddf55fdfbff0">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00979">979</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gae4182cfb7e85ce1cf28603be3ea64891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4182cfb7e85ce1cf28603be3ea64891">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00987">987</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga71b722bb9670854ddfcb0e867620083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b722bb9670854ddfcb0e867620083f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] + y[i] for all i = 0, ..., n-1 where n = std::min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00069">69</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga3f635ef98b56435afb45a039abf9e039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f635ef98b56435afb45a039abf9e039">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array</p>
<p>Perform the element-wise sum between two arrays (x and y) and returns a array z s.t. z[i] = x[i] + y[i] for all i = 0, ..., d where d = x.size() = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00074">74</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga97948a906b46303c7c654c84149dd9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97948a906b46303c7c654c84149dd9ee">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] + y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00109">109</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga7017c5d06814ac672157b881cc29f086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7017c5d06814ac672157b881cc29f086">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] + y for all i = 0, ..., d where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00113">113</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gade9e3b35c5ed9d228bd242eaee48df2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9e3b35c5ed9d228bd242eaee48df2f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x + y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00149">149</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga44d22adb8eb80a55b5379bbc4bcb9422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d22adb8eb80a55b5379bbc4bcb9422">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x + y[i] for all i = 0, ..., d where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00152">152</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga06cb1fde86b09befdc0b42d99fdbf31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cb1fde86b09befdc0b42d99fdbf31f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00187">187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga3ba4d31507040c35f062537329b2f99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ba4d31507040c35f062537329b2f99d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00190">190</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga6e163effd6e58c7f726fbd29f5c1e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e163effd6e58c7f726fbd29f5c1e42c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00228">228</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga46ab5d3f2416d30ad6ed556e513ca15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ab5d3f2416d30ad6ed556e513ca15e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00230">230</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga4a54e162a0893a716a8e767bccc5bcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a54e162a0893a716a8e767bccc5bcf6">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00267">267</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga71c4e0f1fa74771e27be330e94c98fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71c4e0f1fa74771e27be330e94c98fa1">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00268">268</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga0753f57c13e8860d7d89a3c1d38c2f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0753f57c13e8860d7d89a3c1d38c2f73">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga043993b9b79a9ae8c6311907bf739c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043993b9b79a9ae8c6311907bf739c83">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6d4f03731e627c861ab285e02d00f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4f03731e627c861ab285e02d00f7ff">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00344">344</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaf7b6c9177a03b67eb4d3746d11295984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7b6c9177a03b67eb4d3746d11295984">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00345">345</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga1da48a189e6261dbea01a0042d36a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da48a189e6261dbea01a0042d36a814">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between two arrays (x and y) and returns a array z s.t. z[i] = x[i] - y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00385">385</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga39b3f7b4938cab605085cc4a2621c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39b3f7b4938cab605085cc4a2621c0c1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] - y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00386">386</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga3af61c1b7033247df0338ccce0e612d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3af61c1b7033247df0338ccce0e612d6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] - y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00424">424</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga8b14f28bd4c6544e7af363162827a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b14f28bd4c6544e7af363162827a3f9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] - y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00426">426</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga579c90a19cace79621439edbc2d4a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579c90a19cace79621439edbc2d4a73b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x - y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00463">463</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga81916c6a47f24b1ec5bfb890a7e71d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81916c6a47f24b1ec5bfb890a7e71d93">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x - y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00466">466</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga458d5cb02f35f9a5d5bb4ec188ff7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458d5cb02f35f9a5d5bb4ec188ff7df9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::array, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00501">501</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gacd869d6ee14d5683b3fa4fcefc5ae5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd869d6ee14d5683b3fa4fcefc5ae5fa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::vector, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00504">504</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8afe15fc58c619bd07278b1b2bc1fba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8afe15fc58c619bd07278b1b2bc1fba9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., e-1, i = 0, ..., d-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::array, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00541">541</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga043799b065672b453653cccc836df3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043799b065672b453653cccc836df3e0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::vector, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00545">545</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gae07c4511ff8846e22d929bdefc82cd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae07c4511ff8846e22d929bdefc82cd46">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the corresping value on the array at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00579">579</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga0aacb9fe943aadde419e168ee051f35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aacb9fe943aadde419e168ee051f35f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the corresping value on vector at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00584">584</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga98e0e282c16ff506763346bbabbb27a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e0e282c16ff506763346bbabbb27a2">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::array, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00617">617</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gac2595b252e76781008f28f0d4259abd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2595b252e76781008f28f0d4259abd6">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::vector, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00623">623</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8734f21e1ba10ab0e30ca2d98ac458c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8734f21e1ba10ab0e30ca2d98ac458c7">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::vector, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00662">662</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaea724ee1533cefef0eeb081a124145f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea724ee1533cefef0eeb081a124145f2">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::array, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00674">674</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga4d9d274530965b0fb1a331706535b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9d274530965b0fb1a331706535b2b0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] / y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01020">1020</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaf48b3511fe629a19ad6d343b3722b18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf48b3511fe629a19ad6d343b3722b18f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between two arrays (x and y) and returns a array z s.t. z[i] = x[i] / y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01028">1028</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga9ee9c85d60d975df735a1c35fcf02e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee9c85d60d975df735a1c35fcf02e20">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] / y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01060">1060</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga5d819f94a4f2c54f683086dfd60914fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d819f94a4f2c54f683086dfd60914fe">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] / y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01067">1067</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gac6fff4de3b1f6cbedc8b80e0f29b673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fff4de3b1f6cbedc8b80e0f29b673f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x / y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01105">1105</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga17f1060376be7df1fdfaf5372216bb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f1060376be7df1fdfaf5372216bb03">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x / y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01111">1111</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaaa8866a1e9873585704acfa8169ba1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8866a1e9873585704acfa8169ba1f4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01146">1146</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaa5db31c5d90112637e4d2fa84eee9d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5db31c5d90112637e4d2fa84eee9d7e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01151">1151</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gab73845b94584f17c7e810e27cba36f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73845b94584f17c7e810e27cba36f5d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01187">1187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gabb62dde4f70707cef0988601e7ae3c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb62dde4f70707cef0988601e7ae3c08">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01191">1191</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gabef2e8a23bc01ea9a02f8478705a8055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef2e8a23bc01ea9a02f8478705a8055">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01229">1229</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga86745bdc619c80a87b7495a2be35b5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86745bdc619c80a87b7495a2be35b5be">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01231">1231</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5b7c612383329df772db1f49839fea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b7c612383329df772db1f49839fea19">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01261">1261</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gad1c760c866b18096f41015d84c1ba517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c760c866b18096f41015d84c1ba517">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01268">1268</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga50403f99e949516bedf459d21540353c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50403f99e949516bedf459d21540353c">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01291">1291</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga661186ca419d7b771ea549dc2bee4229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga661186ca419d7b771ea549dc2bee4229">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01307">1307</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
</div><!-- contents -->

</div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Fri Aug 10 2018 23:06:24 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
    <div id="footer" >
        <div class="middle">
            <div class="box-wrapper">
                <div class="box bitpit">
                    <p>
                    <strong><a href="/bitpit">bitpit</a></strong><br />
                    <a href="/bitpit/modules/overview.html">Overview</a><br />
                    <a href="/bitpit/downloads">Downloads</a>
                    </p>
                </div>
                <div class="box optimad">
                    <p>
                    <strong><a href="http://www.optimad.it">OPTIMAD Engineering Srl</a></strong><br />
                    <a href="http://www.optimad.it/corporate/spin-off/">About</a><br />
                    <a href="http://www.optimad.it/contact-us/">Contact us</a><br />
                    <a href="mailto:info@optimad.it">info@optimad.it</a>
                    </p>
                </div>
                <div class="box address">
                    <p>
                    <strong>Address</strong><br />
                    Via Giacinto Collegno 18<br />
                    10143 Torino<br />
                    Italy
                    </p>
                </div>
                <div class="box info">
                    <p>
                    <strong>Info</strong><br />
                    Capitale Sociale  10.000,00 i.v.<br />
                    C.F. / P.Iva 09359170017<br />
                    Iscr. Reg. Impr. Torino - R.E.A. TO-1045102
                    </p>
                </div>
            </div>
        </div>
        <div class="legal">
            <p>
             2016-2018 OPTIMAD Engineering Srl  -  <a href="/bitpit/privacy.html">Privacy Policy</a>
            </p>
        </div>
    </div>
</div>
</body>
</html>
